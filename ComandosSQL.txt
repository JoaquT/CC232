//Hacer un backup de base de datos (desde cmd)
C:\Users\.... (donde se encuentre el archivo backup) psql -U postgres -d nombre_basedatos -f nombre_archivo.backup
Luego entrar a psql Shell y verificar la base de datos actualizada


//Tipos de datos
INTEGER -> n√∫meros enteros
SERIAL -> Auto incremental
VARCHAR(n) -> cadenas de texto (hasta n letras)
CHAR(n)->fija el tama√±o exacto a n caracteres. si se ingresa menos se llena con espacios en blanco
TEXT -> texto largo
NUMERIC(p,s) -> n√∫meros con decimales (p=total,s=decimales)
DATE -> Fechas
BOOLEAN -> true/false


//Creando una tabla 	
					
CREATE TABLE nombre_tabla(					
	columna1 tipo_dato [restricciones], //PRIMARY KEY , NOT NULL (colocarlos no siempre es necesario)			
	columna2 tipo_dato [restricciones],			
	‚Ä¶							
	);
//Agregar una columna

ALTER TABLE nombre_tabla
ADD COLUMN nombre_columna tipo_dato [restricciones];
ej:
ALTER TABLE Empleado 
ADD COLUMN edad INTEGER;
//Eliminar una columna
ALTER TABLE nombre_tabla
DROP COLUMN nombre_columna;
ej:
ALTER TABLE Empleado
DROP COLUMN edad;

//Modificar el tama√±o de datos de una columna
ALTER TABLE tabla 
ALTER COLUMN columna 
TYPE nuevo_tipo;

//Eliminar contenido de la tabla
truncate table nombre_tabla;

//Cambiar el tipo de una columna

ALTER TABLE nombre_tabla
ALTER COLUMN nombre_column TYPE nuevo_tipo;
ej:
ALTER TABLE Empleado
ALTER COLUMN salario TYPE INTEGER;

//Renombrar una columna 

ALTER TABLE nombre_tabla
RENAME COLUMN nombre_antiguo TO nombre_nuevo;

//Insertando datos en la tabla 
INSERT INTO nombre_tabla (columna1, columna2, ...)
VALUES (valor1, valor2, ...);
ej:
INSERT INTO Empleado(codEmp, nombre, salario, codDep)
VALUES (1,'Laura P√©rez', 2500.00, 10);

//m√∫ltiples filas
INSERT INTO Empleado (codEmp, nombre, salario, codDep) VALUES
(2, 'Carlos Ruiz', 3000.00, 10),
(3, 'Ana G√≥mez', 2800.00, 20);

//Update - para modificar una o m√°s tuplas existentes
UPDATE tabla 
set columna1 = nuevo_valor1, columna2 = nuevo_valor2
where condici√≥n;


//Eliminando datos en la tabla 
DELETE FROM nombre_tabla
WHERE condici√≥n;

//Selecci√≥n de tuplas
SELECT * FROM nombre_tabla WHERE condiciones_...
//Selecci√≥n sin repetidos
SELECT DISTINCT nombre_columna FROM nombre_tabla  (para seleccionar todos SELECT ALL nombre_columna FROM nombre_tabla)
//Limit, para especificar el numero de registros a devolver
SELECT nombre_columna FROM nombre_tabla LIMIT numero  
ej:
Select * from personas limit 2;

//Operador IN 
Se usa para especificar multiples valores en una clausula WHERE
SELECT nombre_columna FROM nombre_tabla WHERE nombre_columna IN (valor1,valor2,...)
ej:
SELECT * FROM Personas
WHERE lastname IN (‚ÄòHansen‚Äô, ‚ÄòPettersen‚Äô)

//Proyecci√≥n 
SELECT nombre_columna FROM nombre-tabla WHERE condiciones... 

//Operaci√≥n uni√≥n 

SELECT nombre_columna FROM nombre_tabla UNION SELECT nombre_columna FROM nombre_tabla;
ej:
mibanco=# SELECT "nombre-cliente" FROM impositor UNION
mibanco-# SELECT "nombre-cliente" FROM prestatario;
//uniendo todo 
SELECT nombre_columna FROM nombre_tabla UNION ALL SELECT nombre_columna FROM nombre_tabla;

//Diferencia

SELECT nombre_columna FROM nombre_tabla EXCEPT SELECT nombre_columna FROM nombre_tabla;

//Intersecci√≥n
SELECT nombre_columna FROM nombre_tabla INTERSECT SELECT "nombre_columna" FROM nombre_tabla;

//producto cartesiano

SELECT * FROM nombre_tabla,nombre_tabla2,...;

//NATURAL JOIN -->toma las columnas en com√∫n
SELECT * FROM nombre_tabla NATURAL JOIN  nombre_tabla ‚Ä¶

//LIKE ->Comodines

SELECT * FROM nombre_tabla WHERE nombre_columna like 'simbolo_caracter%'; -->que empiece por 

//Group by  --> agrupa filas que tienen valores iguales en una o m√°s columnas, con el fin de aplicar funciones de agregaci√≥n
como sum ,avg,count,max,min,etc
Select columna_agrupada,funcion_agregada(columna) from tabla group by columna_agrupada;
Ej:
SELECT cliente, SUM(monto) AS total
FROM Ventas
GROUP BY cliente;



//JOIN...USING()  --> m√°s seguro si hay m√°s de una columna en com√∫n que no se desea comparar

SELECT * FROM nombre_tabla join nombre_tabla using(nombre_columna)

//JOIN ..ON() -->especificando cu√°les columnas unir incluso aunque no tengan el mismo nombre

SELECT * FROM nombre_tabla join nombre_tabla on (a.nombre_columna = b.nombre_columna); -->ej

//cross join es simplemente producto cartesiano
SELECT * FROM nombre_tabla cross join nombre_tabla;

//left outer join se muestran las filas de la tabla izquierda y las filas coincidentes de la derecha, las no coincidencias se llenan con null

SELECT * FROM tabla_izquierda LEFT JOIN tabla_derecha ON tabla_izquierda.columna = tabla_derecha.columna;

// tambi√©n es posible hacer especificaciones como select *from empleados where departamento_id is NULL;

// Seleccionando departamentos donde no hay empleados
select departamento_nombre from departamentos where departamento_id in (select departamento_id from departamentos except select departamento_id from empleados);

//full outer join selecciona las filas de ambas tablas
select * from tabla1 full outer join tabla2 on tabla1.columna = tabla2.columna;

//Sirve para comparar un valor escalar con todos los datos arrojados por la tabla de una subconsulta, dado por ALL
SELECT * 
FROM marineros
WHERE rating > ALL (
  SELECT rating FROM marineros WHERE nombre = 'Homero'
);

Ejemplo de restricciones:

restricciones=# create table cliente(
restricciones(# codigocliente int not null,
restricciones(# nombre varchar(30) not null,
restricciones(# codciudad int,
restricciones(# primary key(codigocliente),
restricciones(# foreign key (codciudad) references
restricciones(# ciudad(codigociudad) on delete set null);
CREATE TABLE

Luego al eliminar alguna fila de la tabla ciudad con una clave primaria, en la tabla cliente, se reemplazara el atributo que hace referencia a ciudad, a null
Restricci√≥n Unique:
- Asegura que los datos contenidos en una columna o grupo de columnas sea unico en relacion a todas las filas de la tabla
Ejemplo: Create table producto(nroProducto integer, nombre varchar(30),precio real,unique(nroProducto));

ON DELETE SET DEFAULT:
CREATE TABLE departamento (
    id_depto TEXT PRIMARY KEY,
    nombre TEXT
);

CREATE TABLE empleado (
    id_empleado TEXT PRIMARY KEY,
    nombre TEXT,
    id_depto TEXT DEFAULT 'DEP000',  -- valor por defecto si se elimina el depto
    FOREIGN KEY (id_depto) REFERENCES departamento(id_depto)
        ON DELETE SET DEFAULT
);
ON DELETE RESTRICT es una regla de integridad referencial que impide eliminar una fila de la tabla padre si existen registros relacionados en la tabla hija.
CREATE TABLE departamento (
    id_depto TEXT PRIMARY KEY,
    nombre TEXT
);

CREATE TABLE empleado (
    id_empleado TEXT PRIMARY KEY,
    nombre TEXT,
    id_depto TEXT,
    FOREIGN KEY (id_depto) REFERENCES departamento(id_depto)
        ON DELETE RESTRICT
);
ON DELETE CASCADE es una regla en claves for√°neas que elimina autom√°ticamente las filas relacionadas en la tabla hija cuando se elimina una fila en la tabla padre.
CREATE TABLE departamento (
    id_depto TEXT PRIMARY KEY,
    nombre TEXT
);
CREATE TABLE empleado (
    id_empleado TEXT PRIMARY KEY,
    nombre TEXT,
    id_depto TEXT,
    FOREIGN KEY (id_depto) REFERENCES departamento(id_depto)
        ON DELETE CASCADE
);

RESTRICCIONES SEMANTICAS
Las restricciones sem√°nticas en bases de datos son reglas que imponen condiciones l√≥gicas adicionales sobre los datos, m√°s all√° de las restricciones estructurales como tipos de datos o claves primarias. Estas reglas reflejan el significado y la l√≥gica del dominio del problema que modela la base de datos.

Restricci√≥n de valores v√°lidos:

Un campo edad debe ser mayor que 0.
CHECK (edad > 0)

Restricci√≥n de rango l√≥gico:

Un atributo calificacion debe estar entre 0 y 20.
CHECK (calificacion BETWEEN 0 AND 20)

CREATE TABLE empleado (
    id TEXT PRIMARY KEY,
    nombre TEXT,
    salario NUMERIC CHECK (salario >= 0)
);


---DOMINIOS-----
Un dominio en PostgreSQL es un tipo de dato basado en otro tipo, pero con restricciones extra (CHECK, NOT NULL, etc.).
EJEMPLO:CREATE DOMAIN edad_pos AS INTEGER
CHECK (VALUE > 0);
CREATE TABLE persona (
    id SERIAL PRIMARY KEY,
    nombre TEXT NOT NULL,
    edad edad_pos  -- ¬°Aqu√≠ usamos el dominio!
);
-- ‚úî Correcto
INSERT INTO persona (nombre, edad) VALUES ('Ana', 25);

-- ‚ùå Falla (violaci√≥n del dominio)
INSERT INTO persona (nombre, edad) VALUES ('Luis', -5);
-- ERROR:  value for domain edad_pos violates check constraint "edad_pos_check"
MAS EJEMPLOS:
CREATE DOMAIN nombrevalido as varchar(40);
CREATE DOMAIN logico as boolean
CHECK(VALUE IN (TRUE,FALSE))
DEFAULT TRUE;

CREATE DOMAIN nota_valida AS numeric(5,2)
CHECK (VALUE >= 0.00 AND VALUE <= 20.00);

CREATE DOMAIN tiposocio as char(1)
check(value in ('P','A'));
---En un dominio, debes referirte al valor insertado como VALUE, no por el nombre del dominio.

----VISTAS---
Una vista es una tabla virtual basada en el resultado de una consulta (SELECT). No almacena datos por s√≠ misma, sino que muestra datos de otras tablas de manera din√°mica.
Sintaxis b√°sica para crear una vista
CREATE VIEW nombre_vista AS
SELECT columna1, columna2
FROM tabla
WHERE condici√≥n;

Eliminar una vista
DROP VIEW nombre_vista;

OPCIONES PARA EDITAR UNA VISTA
‚úÖ 1. Usar CREATE OR REPLACE VIEW
Es la forma m√°s com√∫n y recomendada.
CREATE OR REPLACE VIEW nombre_vista AS
SELECT ...
FROM ...
WHERE ...;
Ejemplo:
---Anterior----
CREATE VIEW empleados_ventas_activos AS
SELECT nombre, cargo, salario
FROM empleados
WHERE departamento = 'Ventas' AND estado = 'Activo';

---Actualizar----
CREATE OR REPLACE VIEW empleados_ventas_activos AS
SELECT nombre, cargo
FROM empleados
WHERE departamento = 'Ventas';


--VISTAS SOBRE VISTAS---
Ejemplo paso a paso
üß± 1. Vista base (simple)
CREATE VIEW vista_empleados_activos AS
SELECT id, nombre, departamento
FROM empleados
WHERE estado = 'Activo';
üß± 2. Vista que usa la vista anterior
CREATE VIEW vista_empleados_activos_ventas AS
SELECT *
FROM vista_empleados_activos
WHERE departamento = 'Ventas';


---AUTORIZACION DE ACCESO---
La autorizaci√≥n de acceso es el mecanismo que permite controlar qu√© usuarios pueden hacer qu√© cosas en una base de datos: ver, modificar, eliminar o administrar objetos (tablas, vistas, funciones, esquemas, etc.).

üë• Tipos de usuarios/roles
En PostgreSQL, se usan roles, que pueden actuar como:

Usuarios (roles que pueden iniciar sesi√≥n)

Grupos (roles que agrupan permisos para compartirlos)

Puedes crearlos as√≠:

CREATE ROLE nombre LOGIN PASSWORD 'clave';
-- o
CREATE USER nombre WITH PASSWORD 'clave';
‚úÖ Comando clave: GRANT
Otorga permisos a un usuario o rol:
GRANT privilegios ON objeto TO usuario;
üìå Ejemplos:

-- Dar permiso de SELECT sobre una tabla
GRANT SELECT ON empleados TO juan;

-- Dar todos los permisos (SELECT, INSERT, UPDATE, DELETE)
GRANT ALL PRIVILEGES ON empleados TO juan;

-- Permitir uso de un esquema
GRANT USAGE ON SCHEMA public TO juan;

Comando opuesto: REVOKE
Quita permisos:
REVOKE SELECT ON empleados FROM juan;
Caso pr√°ctico

-- Crear usuario
CREATE USER analista WITH PASSWORD 'clave123';

-- Dar acceso de solo lectura a una tabla
GRANT SELECT ON empleados TO analista;

-- Permitirle usar el esquema public
GRANT USAGE ON SCHEMA public TO analista;

üö´ PostgreSQL no permite directamente restringir el acceso a columnas espec√≠ficas de una tabla.
Es decir, no puedes decir:

‚ÄúDale a este usuario acceso a la tabla empleados excepto a la columna salario‚Äù.

Sin embargo, hay soluciones pr√°cticas para lograr este comportamiento.

‚úÖ Soluciones posibles
üî∏ Opci√≥n 1: Crear una vista sin la columna restringida
Esta es la forma m√°s com√∫n y segura.

CREATE VIEW vista_empleados_publicos AS
SELECT id, nombre, cargo
FROM empleados;
Luego, otorgas permiso solo a la vista:

GRANT SELECT ON vista_empleados_publicos TO usuario;

---¬øQu√© es un rol en PostgreSQL?---
Un rol puede ser:

Un usuario (si tiene permiso para iniciar sesi√≥n: LOGIN)

Un grupo de usuarios (si no tiene LOGIN, act√∫a como contenedor de permisos)

Roles permiten asignar y administrar permisos de manera flexible y reutilizable.

üë§ Crear un usuario (rol con login)
CREATE ROLE juan LOGIN PASSWORD 'clave123';
O:
CREATE USER juan WITH PASSWORD 'clave123';
Ambos comandos son equivalentes en la pr√°ctica.

üë• Crear un rol tipo grupo (sin login)
CREATE ROLE solo_lectura;
Luego puedes asignar ese rol a usuarios:

GRANT solo_lectura TO juan;
Ahora, juan hereda todos los permisos de solo_lectura.

üîÅ Roles anidados (jerarqu√≠a de permisos)
Puedes tener:

Rol solo_lectura con permisos de SELECT

Rol analistas que incluye solo_lectura

Usuario ana que pertenece a analistas

Esto permite reutilizar permisos sin repetir GRANTs a cada usuario.

üõ†Ô∏è Otorgar permisos a un rol
-- Crear rol de solo lectura
CREATE ROLE solo_lectura;

-- Dar permiso de lectura sobre la tabla
GRANT SELECT ON empleados TO solo_lectura;

-- Asignar ese rol a un usuario
GRANT solo_lectura TO pedro;
Ahora pedro puede hacer SELECT sobre empleados, aunque no se le dio acceso directo.

üîí Ver roles y relaciones
üìã Ver todos los roles:
\du
üîç Ver a qu√© roles pertenece un usuario:
SELECT rolname
FROM pg_roles
WHERE pg_has_role('juan', oid, 'member');
üßæ Revocar roles y permisos
REVOKE solo_lectura FROM pedro;
REVOKE SELECT ON empleados FROM solo_lectura;
‚úÖ Buenas pr√°cticas
Usa roles tipo grupo (sin LOGIN) para agrupar permisos.

Usa GRANT ... TO ... para delegar permisos a roles.

Evita dar permisos directamente a cada usuario.

Usa vistas para refinar el acceso a datos sensibles.

Suponga que el DBA cree 4 cuentas U1, U2, U3 y U4.
‚ñ† 1) Solamente U1 debe crear relaciones en la base de
datos (privilegio de cuenta)
‚óª grant createTab to U1
‚ñ† 2) con esa autorizaci√≥n el usuario U1 puede crear
relaciones y tendr√° TODOS los privilegios sobre ellas
‚óª Suponga que U1 creo las relaciones
Empleado (codEmp, nombre, categoria, salario)
Proyecto (#codProy, tipo, descripcion)
ProyectoEmpleado (# codProy, # codEmp, fechaInicial, fechaFinal)
Ejemplo Completo
‚ñ† 3) Suponga que U1 quiere dar al usuario U2
permiso para incluir y remover tuplas en
Empleado y Proyecto
‚óª grant INSERT, DELETE ON EMPLEADO,PROYECTO TO U2
‚ñ† 4) Suponga que U1 quiere dar al usuario U3
permiso para recuperar tuplas en Empleado y
sea capaz de PROPAGAR este privilegio
‚óª grant SELECT ON EMPLEADO TO U3 WITH GRANT OPTION

--Otra forma de manejar las vistas:
CREATE VIEW vista_ejemplo (nombre, edad) AS
SELECT 'Luis', 30;
CREATE VIEW vista_02(codigoproducto,nombreproducto,preciototal) as 
select idproducto,nombreproducto,preciounidad*unidadesexistencia from productos;



---Indices-----
√çNDICES EN POSTGRESQL
üîπ ¬øQu√© es un √≠ndice?
Un √≠ndice es una estructura de datos que permite acceder a los datos de una tabla m√°s r√°pidamente. Funciona como un √≠ndice de libro: te lleva directo al lugar donde est√° la informaci√≥n.

üîπ ¬øPara qu√© sirven?
Acelerar b√∫squedas con SELECT, especialmente con WHERE

Mejorar el rendimiento en condiciones de ordenaci√≥n (ORDER BY), b√∫squeda por rangos, y uniones (JOIN)

Impulsar el rendimiento en columnas √∫nicas o clave primaria

üîπ Tipos de √≠ndices en PostgreSQL
Tipo de √≠ndice	Uso principal	Caracter√≠sticas
btree (por defecto)	Comparaciones, rangos (=, <, >, BETWEEN)	Balanceado, r√°pido
hash	Comparaciones por igualdad (=)	R√°pido, pero limitado
gin (Generalized Inverted Index)	B√∫squedas en arrays, texto completo (tsvector)	Ideal para b√∫squedas complejas
gist	B√∫squedas geogr√°ficas, proximidad	Usado con PostGIS
spgist, brin, etc.	Casos especiales como grandes vol√∫menes, geometr√≠a, etc.	M√°s avanzados

üîπ Sintaxis para crear √≠ndices
CREATE INDEX idx_nombre ON tabla(columna);
Ejemplo:

CREATE INDEX idx_empleado_nombre ON empleados(nombre);
üîπ √çndices √∫nicos
Aseguran que no haya valores duplicados en una columna o conjunto de columnas:

CREATE UNIQUE INDEX idx_email_unico ON usuarios(email);
üîπ El motor decide si lo usa
Los √≠ndices no garantizan mejoras autom√°ticas. PostgreSQL decide cu√°ndo usarlos seg√∫n las estad√≠sticas.

üîπ Cuidados al usar √≠ndices
Aceleran lecturas pero pueden ralentizar escrituras (INSERT, UPDATE, DELETE).

No crees √≠ndices innecesarios.

Reindexa si los √≠ndices se fragmentan mucho:

REINDEX INDEX idx_nombre;

---TIPOS DE INDICES----
BTREE: CREATE INDEX idx_nombre ON tabla(columna);
HASH: CREATE INDEX idx_nombre_hash ON tabla USING hash(columna);
GIN: CREATE INDEX idx_contenido_gin ON tabla USING gin(columna);
GIST: CREATE INDEX idx_gist ON tabla USING gist(columna);
SP-GIST: CREATE INDEX idx_spgist ON tabla USING spgist(columna);
BRIN: CREATE INDEX idx_brin ON tabla USING brin(columna);
EXPRESSION INDEXES: CREATE INDEX idx_lower_nombre ON tabla(LOWER(nombre));
PARTIAL INDEXES: CREATE INDEX idx_condicional ON tabla(columna) WHERE estado = 'activo';


---EJEMPLO DE SECUENCIAS----
CREATE SEQUENCE secuencia_id
    START WITH 1
    INCREMENT BY 1
    MINVALUE 1
    MAXVALUE 99999
    CYCLE; 
C√≥mo se usa esta secuencia?
Una vez creada, la usas con la funci√≥n nextval('nombre_secuencia'), por ejemplo:

SELECT nextval('secuencia_id');
Esto te devuelve el siguiente n√∫mero generado por la secuencia.

üîÅ ¬øD√≥nde se puede usar nextval?
En un INSERT directamente:

INSERT INTO libros (id_libro, titulo)
VALUES (nextval('secuencia_id'), 'Cien a√±os de soledad');
Como valor por defecto en una tabla:

CREATE TABLE libros (
    id_libro INTEGER DEFAULT nextval('secuencia_id'),
    titulo TEXT
);
As√≠, cuando insertes sin pasar id_libro, lo genera solo:


INSERT INTO libros (titulo)
VALUES ('El Principito');
üîÅ ¬øQu√© hace el CYCLE?
Si haces esto repetidamente:


SELECT nextval('secuencia_id');
Cuando llegue a 99999, volver√° a 1 (en lugar de lanzar un error como lo har√≠a una secuencia normal sin CYCLE).

üîé Ver estado de la secuencia:

SELECT * FROM pg_sequences WHERE schemaname = 'public';
O m√°s directo:

SELECT last_value, is_cycled FROM secuencia_id;

----ejemplo:Defina la secuencia suc_01 con primer t√©rmino 10, √∫ltimo t√©rmino 750 y raz√≥n 10
CREATE SEQUENCE suc_01
    START WITH 10
    INCREMENT BY 10
    MINVALUE 10
    MAXVALUE 750;

Perfecto. Vamos a asociar la secuencia suc_01 al atributo codigo de la tabla docente. Aqu√≠ tienes dos opciones seg√∫n si la tabla ya existe o si la est√°s creando desde cero.

‚úÖ ‚ë† Si la tabla ya existe:
Supongamos que la tabla docente ya tiene una columna llamada codigo. Para asociar la secuencia, haces esto:

ALTER TABLE docente
ALTER COLUMN codigo SET DEFAULT nextval('suc_01');
Esto har√° que cada vez que insertes un nuevo docente sin especificar el codigo, se use autom√°ticamente el siguiente valor de suc_01.

‚úÖ ‚ë° Si est√°s creando la tabla desde cero:
Puedes definir el DEFAULT directamente as√≠:

CREATE TABLE docente (
    codigo INTEGER DEFAULT nextval('suc_01'),
    nombre TEXT,
    apellido TEXT
    -- otros atributos...
);
üß™ Ejemplo de uso:

INSERT INTO docente (nombre, apellido) VALUES ('Luis', 'Zamora');
INSERT INTO docente (nombre, apellido) VALUES ('Ana', 'Garc√≠a');

-- Ver los resultados:
SELECT * FROM docente;
